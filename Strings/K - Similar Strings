Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2.
Given two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.

Example 1:
Input: s1 = "ab", s2 = "ba"
Output: 1
Explanation: The two string are 1-similar because we can use one swap to change s1 to s2: "ab" --> "ba".

Example 2:
Input: s1 = "abc", s2 = "bca"
Output: 2
Explanation: The two strings are 2-similar because we can use two swaps to change s1 to s2: "abc" --> "bac" --> "bca".

Constraints:
1 <= s1.length <= 20
s2.length == s1.length
s1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.
s2 is an anagram of s1.

## SOLUTION ##
class Solution:
    def kSimilarity(self, s1: str, s2: str) -> int:
        ans = 0
        seen = {s1}
        queue = deque([s1])
        while queue: 
            for _ in range(len(queue)): 
                s = queue.popleft()
                if s == s2: return ans 
                for i in range(len(s)): 
                    if s[i] != s2[i]: 
                        for j in range(i+1, len(s)): 
                            if s[j] != s2[j] and s[j] == s2[i]: 
                                ss = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]
                                if ss not in seen: 
                                    seen.add(ss)
                                    queue.append(ss)
                        break
            ans += 1
